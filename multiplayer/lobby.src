// Multiplayer Game Lobby.
// People join the lobby, and allows them to start new multiplayer games.

CONTROLLER_FILENAME = home_dir + "/.controller.txt"
IMPORT_BIN = home_dir + "/bin/import"
DOWNLOAD_DIR = home_dir + "/Downloads"
WAIT_TIME = 1.0

CONTROLLER_FILE = get_shell.host_computer.File(CONTROLLER_FILENAME)
if CONTROLLER_FILE == null then
    get_shell.host_computer.touch(home_dir, ".controller.txt")
    CONTROLLER_FILE = get_shell.host_computer.File(CONTROLLER_FILENAME)
end if
if CONTROLLER_FILE == null or CONTROLLER_FILE.is_binary then
    exit("Could not set up controller file " + CONTROLLER_FILENAME)
end if
CONTROLLER_FILE.set_content("")

main = function()
    if params.len != 2 or params.indexOf("-h") != null or params.indexOf("--help") != null then
        print("Usage: " + program_path + " [-h | --help] configfile handle")
        print("")
        print(" -h | --help       This help screen.")
        print(" configfile        Location of the configuration file for connecting to the game server.")
        print(" handle            Your alias when playing games on the server.")
        exit
    end if

    userHandle = params[1]
    if IsInvalidName(userHandle) then
        exit("Invalid user handle.  It must be alpha-numeric (a-z, A-Z, 0-9)")
    end if

    ctrlIdx = ""
    NextCommand = function()
        val = CONTROLLER_FILE.get_content
        if val == "exit" then return [2, ""]
        pos = val.indexOf("|")
        if pos == null then return null
        idx = val[:pos]
        if idx != outer.ctrlIdx then
            // New command
            outer.ctrlIdx = idx
            if val[pos+1] == "!" then return [1, val[pos+2:]]
            return [0, val[pos+2:]]
        end if
        return null
    end function

    lastWhen = ""

    DrawMessage = function(msg)
        when = msg[0]
        if when != outer.lastWhen then
            print("<color=#000090>" + when)
            outer.lastWhen = when
        end if
        name = msg[1]
        msg = msg[2]
        if name[0] == "/" then
            print("<color=#10ff60>" + name + "</color> <color=#aaa>" + msg)
        else if msg[:7] == "/emote " then
            print("<i><color=#808000>" + name + "</color> <noparse>" + msg[7:] + "</noparse>")
        else
            print("<color=#808000>" + name + "</color><color=#aaa>: <noparse>" + msg + "</noparse>")
        end if
    end function

    server = GameServer.LoadFrom(params[0])
    if server == null then exit("Failed to load server configuration.")
    res = server.Connect()
    if res != null then exit("Failed to connect to server: " + res)
    print("<color=#aaaaaa><i>Connected to " + server.addr + ":" + server.port)
    print("<color=#f08040>" + server.About)

    state = 0
    lobby = null
    joinedGame = null
    while true
        // ............................................................
        // Lobby
        if state == 0 then
            // In the lobby
            if joinedGame != null then
                joinedGame.Disconnect()
                joinedGame = null
            end if
            if lobby == null then
                lobby = server.EnterLobby(userHandle, false)
                if lobby == null then
                    print("Failed to connect to lobby. Someone else may already be using your handle.")
                    return
                end if
                // First time.  Refresh the screen with the lobby stuff.
                print("<color=#008080>Entering lobby.  Current members: " + lobby.GetMembers)
                print("Enter '/help' in your controller terminal for help.")
            end if
            // Pull messages and post them
            for message in lobby.PullMessages
                DrawMessage(message)
            end for
            cmd = NextCommand()
            if cmd != null and cmd[0] == 2 then
                lobby.Disconnect()
                exit("Controller quit.  Quitting lobby, too.")
            end if
            if cmd != null and cmd[0] == 0 and cmd[1] != "" then
                req = cmd[1]
                words = Words(req)
                // ----------------------------------------------------
                // Describe a game
                if words[0] == "/about" then
                    if words.len != 2 then
                        print("<color=#ff5060><i>Usage: /about (game name)")
                    else
                        game = server.GetGame(words[1])
                        if game == null then
                            print("<color=#ff5060><i>Unknown game '" + words[1] + "'; use '/games' to list known games")
                        else
                            print("<color=#20ff20><noparse>" + game.Name + "</noparse>")
                            print("<color=#808080>  Player count: " + game.MinPlayers + " - " + game.MaxPlayers)
                            if game.About != null then print(game.About)
                        end if
                    end if
    
                // ----------------------------------------------------
                // List Users
                else if words[0] == "/users" then
                    // TODO this should also fetch when the user last posted.
                    print(lobby.GetMembers)
                
                // ----------------------------------------------------
                // List Games
                else if words[0] == "/games" then
                    for gameName in server.KnownGames.indexes
                        game = server.KnownGames[gameName]
                        msg = "<color=#20ff20><noparse>" + game.Name + "</noparse></color> (" + gameName + ")"
                        if game.Description != null then msg = msg + " <color=#a0a0a0>" + game.Description
                        print(msg)
                    end for

                // ----------------------------------------------------
                // List Instances
                else if words[0] == "/list" then
                    if words.len != 2 then
                        print("<color=#ff5060><i>Usage: /list (game name)")
                    else
                        game = server.GetGame(words[1])
                        if game == null then
                            print("<color=#ff5060><i>Unknown game '" + words[1] + "'; use '/games' to list known games")
                        else
                            for instanceName in game.PendingGames.indexes
                                msg = "<color=#6060ff><i><noparse>" + instanceName + "</noparse></color> "
                                instance = game.PendingGames[instanceName]
                                status = instance.Status
                                statusMsg = "<color=#20ff20>Waiting for players</color>"
                                if status == "full" then statusMsg = "<color=#606080>Instance full</color>"
                                if status == "abandoned" then statusMsg = "<color=#404040>Abandonded</color>"
                                if status == "starting" then statusMsg = "<color=#806060>Starting</color>"
                                print(msg + statusMsg)
                            end for
                        end if
                    end if

                // ----------------------------------------------------
                // Host a new instance
                else if words[0] == "/host" then
                    if words.len != 3 then
                        print("<color=#ff5060><i>'/host' usage: /host game-name instance-name")
                    else
                        game = server.GetGame(words[1])
                        if game == null then
                            print("<color=#ff5060><i>Unknown game '" + words[1] + "'; use '/games' to list known games")
                        else
                            joinedGame = game.HostGame(words[2], userHandle)
                            if joinedGame == null then
                                print("<color=#ff5060><i>Failed to host game")
                            else
                                state = 1
                                print("<color=#20ff40>Hosting Game " + game.Name + ", instance " + joinedGame.InstanceName)
                                lobby.PostMessage("/emote started game " + game.Name + " instance " + joinedGame.InstanceName)
                                lobby.Disconnect()
                                lobby = null
                            end if
                        end if
                    end if

                // ----------------------------------------------------
                // Join an instance
                else if words[0] == "/join" then
                    if words.len != 3 then
                        print("<color=#ff5060><i>'/join' usage: /join gameName instanceName")
                    else
                        game = server.GetGame(words[1])
                        if game == null then
                            print("<color=#ff5060><i>Unknown game '" + words[1] + "'; use '/games' to list known games")
                        else
                            joinedGame = game.JoinGame(words[2], userHandle)
                            if joinedGame == null then
                                print("<color=#ff5060><i>Failed to join game")
                            else
                                state = 2
                                print("<color=#20ff40>Joined Game " + game.Name + ", instance " + joinedGame.InstanceName)
                                lobby.Disconnect()
                                lobby = null
                            end if
                        end if
                    end if

                // ----------------------------------------------------
                // Quit the lobby / server.
                else if words[0] == "/quit" then
                    lobby.Disconnect()
                    lobby = null
                    state = -1
                    exit("Quitting the lobby.")

                // ----------------------------------------------------
                // Help
                else if words[0] == "/help" then
                    print("Type in text to have it be posted to the lobby.")
                    print("You can also use 'slash' commands, like this /help command.")
                    print("Supported commands:")
                    print("  <color=#808080>/help</color>     This text.")
                    print("  <color=#808080>/quit</color>     Quit the lobby.")
                    print("  <color=#808080>/games</color>    List the games available on the server.")
                    print("  <color=#808080>/users</color>    List the users in the lobby.")
                    print("  <color=#808080>/list (game)</color>  List the pending instances for the game, waiting for players.")
                    print("  <color=#808080>/about (game)</color>  Describe the game.")
                    print("  <color=#808080>/join (game) (instance)</color>  Join the pending game with the given instance name.")
                    print("  <color=#808080>/host (game) (instance)</color>  Host a new game with the given instance name.")
                
                // ----------------------------------------------------
                // Post a message
                else
                    lobby.PostMessage(req)
                    print("<color=#ffffff><noparse>:: " + req + "</noparse>")
                end if
            else
                // wait if nothing to do based on controller state.
                wait(WAIT_TIME)
            end if

        // ............................................................
        // Hosted (1) or Joined (2) Game
        else if state == 1 or state == 2 then
            // In the pending game
            if joinedGame == null then
                if lobby != null then lobby.Disconnect()
                exit("Bad state: joined game is null")
            end if
            // Pull messages and post them
            for message in joinedGame.PullMessages
                DrawMessage(message)
            end for

            if joinedGame.InstanceStatus == "active" and not joinedGame.IsHosting then
                // Game has started.  Need to join the game.
                print("Joining the game in progress.")
                joinedGame.Launch()
                joinedGame.Disconnect()
                joinedGame = null
                print("Entering the lobby.")
                state = 0
            end if

            cmd = NextCommand()
            if cmd != null and cmd[0] == 2 then
                joinedGame.Disconnect()
                joinedGame = null
                state = -1
                exit("Controller quit.  Quitting the joined game, too.")
            end if
            if cmd != null and cmd[0] == 0 then
                req = cmd[1]
                words = Words(req)
                // ----------------------------------------------------
                // Describe a game
                if words[0] == "/about" then
                    game = joinedGame.Game
                    print("<color=#20ff20><noparse>" + game.Name)
                    print("<color=#808080>  Player count: " + game.MinPlayers + " - " + game.MaxPlayers)
                    if game.About != null then print(game.About)

                // ----------------------------------------------------
                // Leave for the lobby
                else if words[0] == "/leave" or words[0] == "/lobby" then
                    joinedGame.PostMessage("/emote left the instance.")
                    joinedGame.Disconnect()
                    state = 0

                // ----------------------------------------------------
                // Start the game
                else if words[0] == "/start" and joinedGame.IsHosting then
                    res = joinedGame.CanStart
                    if res != null then
                        print("<color=#ff5060><i>Cannot start the game: " + res)
                    else
                        joinedGame.Launch()
                        joinedGame.Disconnect()
                        joinedGame = null
                        state = 0
                    end if

                // ----------------------------------------------------
                // List people in the pending game + their status.
                else if words[0] == "/users" then
                    res = joinedGame.FetchPlayerStatus
                    for name in res.indexes
                        print("<color=#4040ff>" + name + " : " + res[name])
                    end for

                // ----------------------------------------------------
                // Help
                else if req == "/help" then
                    print("Type in text to have it be posted to the lobby.")
                    print("You can also use 'slash' commands, like this /help command.")
                    print("Supported commands:")
                    print("  <color=#808080>/help</color>     This text.")
                    print("  <color=#808080>/leave</color>    Leave this pending game and go back to the lobby.")
                    print("  <color=#808080>/lobby</color>    Leave this pending game and go back to the lobby.")
                    print("  <color=#808080>/users</color>    List of players in this pending game instance.")
                    print("  <color=#808080>/quit</color>     Quit the server.")
                    print("  <color=#808080>/about</color>    Describe this game.")
                    print("  <color=#808080>/status (status)</color>  Set your status.  Used to indicate whether you're ready to play.")
                    if joinedGame.IsHosting then
                        print("  <color=#808080>/start</color>  Start the game (host only)")
                    end if

                // ----------------------------------------------------
                // Quit the lobby / server.
                else if req == "/quit" then
                    joinedGame.Disconnect()
                    joinedGame = null
                    state = -1
                    exit("Quitting the server.")

                // ----------------------------------------------------
                // Post a message
                else
                    joinedGame.PostMessage(req)
                    print("<color=#ffffff><noparse>:: " + req + "</noparse>")
                end if
            else
                // wait if nothing to do based on controller state.
                wait(WAIT_TIME)
            end if

        // ............................................................
        // Unknown state; quit.
        else
            if joinedGame != null then joinedGame.Leave()
            if lobby != null then lobby.Disconnect()
            print("Quitting server.")
            return
        end if
    end while
end function

// ====================================================================
// Game Server + Everything Else Library Code

GameServer = {}
GameServer.LoadFrom = function(filename)
    file = get_shell.host_computer.File(filename)
    if file == null then file = get_shell.host_computer.File(current_path + "/" + filename)
    if file == null then file = get_shell.host_computer.File(home_dir + "/" + filename)
    if file == null then
        print("Could not find local file '" + filename + "'")
        return null
    end if
    props = ParsePropertyFile(file.get_content)
    addr = null
    username = "guest"
    passwd = "guest"
    port = 21
    service = "ftp"
    serverRootDir = "/home/guest"
    if props.hasIndex("ip") then addr = props.ip
    if props.hasIndex("username") then username = props.username
    if props.hasIndex("password") then passwd = props.password
    if props.hasIndex("port") then port = props.port
    if props.hasIndex("service") then service = props.service
    if props.hasIndex("dir") then serverRootDir = props.dir
    if addr == null then
        print("No 'ip' field set in the game property file '" + filename + "'")
        return null
    end if
    return GameServer.Server.mk(addr, username, passwd, port, service, serverRootDir)
end function

GameServer.Server = {}
GameServer.Server.mk = function(addr, username, passwd, port, service, serverRootDir)
    ret = new GameServer.Server
    // GameName The game's name, so that the player only interacts with people in the same game.
    ret.addr = addr
    ret.username = username
    ret.passwd = passwd
    if port isa string then port = port.to_int
    ret.port = port
    ret.service = service
    ret.serverRootDir = serverRootDir
    ret.server = null
    ret.queue = {}
    ret.sendId = {}
    ret.recvId = {}
    ret.knownGames = {}
    return ret
end function

// Server.Connect Connect to the server.  Returns a string on error, and null on okay.
GameServer.Server.Connect = function(user=null, passwd=null)
    if user == null then user = self.username
    if passwd == null then passwd = self.passwd
    if self.server == null then
        if self.addr == "localhost" then
            srv = get_shell
        else
            srv = get_shell.connect_service(self.addr, self.port, user, passwd, self.service)
        end if
        if srv isa string then
            return srv
        end if
        self.server = srv
    end if
    return null
end function

// Server.About Get the game server's basic description.
GameServer.Server.About = function()
    if self.server == null then return "(unconnected)"
    file = self.server.host_computer.File(self.serverRootDir + "/about.txt")
    if file == null then return "Basic Multiplayer Game Server"
    ret = file.get_content
    if ret == null then return "(can't access server files)"
    return ret
end function

// Server.EnterLobby Connect to the lobby.  Returns a string on error or the Lobby object.
GameServer.Server.EnterLobby = function(playerName, force=false)
    return GameServer.Lobby.mk(self, playerName, force)
end function

// Server.GetGame Match the game name against the known list.
//
// Will only fetch games if the list is empty.
GameServer.Server.GetGame = function(gameName)
    known = self.KnownGames
    words = Words(gameName)
    if words.len != 1 then return null
    gameName = words[0].lower
    if known.hasIndex(gameName) then return known[gameName]
    for simpleName in known.indexes
        game = known[simpleName]
        if gameName == game.Name.lower then return game
    end for
    return null
end function

// Server.FetchGames Get a map of all games on the server.
GameServer.Server.FetchGames = function()
    if self.server == null then return {}
    self.knownGames = {}
    for item in self.listDirsIn(self.serverRootDir + "/Games")
        gameName = item.name
        gameDir = item.path
        aboutFile = self.server.host_computer.File(gameDir + "/about.txt")
        infoFile = self.server.host_computer.File(gameDir + "/gameinfo.txt")
        if aboutFile == null or infoFile == null then continue
        game = GameServer.GameInfo.mk(self, aboutFile, infoFile)
        if game != null then
            self.knownGames[game.SimpleName.lower] = game
        end if
    end for
    return self.knownGames
end function

// Server.KnownGames Get the map of simple name to game info.
GameServer.Server.KnownGames = function()
    if self.knownGames.len <= 0 then self.FetchGames
    return self.knownGames
end function

GameServer.msgSep = char(1)
GameServer.maxQueueLen = 100
GameServer.Server.post = function(location, action)
    if self.server == null then return "not connected"
    if action.indexOf(GameServer.msgSep) != null then return "invalid message content"
    if not location isa list or location.len != 2 then exit("post: Invalid API usage")
    locStr = location[0] + "/" + location[1]
    if not self.sendId.hasIndex(locStr) then self.sendId[locStr] = 0
    if not self.queue.hasIndex(locStr) then self.queue[locStr] = []
    if self.queue[locStr].len >= GameServer.maxQueueLen then self.queue[locStr].pull
    self.sendId[locStr] = self.sendId[locStr] + 1
    self.queue[locStr].push([str(self.sendId[locStr]), current_date, action])
    content = ""
    for msg in self.queue[locStr]
        content = content + GameServer.msgSep + msg[0] + "." + msg[1] + "." + msg[2]
    end for
    content = content[1:]

    file = self.getOrMkFile(location)
    if file == null then return "failed to access '" + location[0] + "/" + location[1] + "'"
    res = file.set_content(content)
    if res isa string then return res
    return null
end function

GameServer.Server.closePost = function(location)
    if not location isa list or location.len != 2 then exit("post: Invalid API usage")
    locStr = location[0] + "/" + location[1]
    if self.queue.hasIndex(locStr) then self.queue.remove(locStr)
    if self.sendId.hasIndex(locStr) then self.sendId.remove(locStr)
    self.rmFile(location)
end function

GameServer.Server.pull = function(location)
    // pull all available messages from the location since the last pull.
    if not location isa list or location.len != 2 then exit("post: Invalid API usage")
    if self.server == null then return []
    locStr = location[0] + "/" + location[1]
    maxRecvId = -1
    if self.recvId.hasIndex(locStr) then maxRecvId = self.recvId[locStr]
    prevRecvId = maxRecvId
    file = self.getExistingFile(location)
    if file == null then return []
    res = file.get_content
    if res == null then return []
    ret = []
    for message in res.split(GameServer.msgSep)
        p1 = message.indexOf(".")
        if p1 == null then continue
        idx = message[:p1].to_int
        if idx <= prevRecvId then continue
        if idx > maxRecvId then maxRecvId = idx
        p2 = message.indexOf(".", p1 + 1)
        if p2 == null then continue
        ret.push([idx, message[p1+1:p2], message[p2+1:]])
    end for
    self.recvId[locStr] = maxRecvId
    return ret
end function

GameServer.Server.listIn = function(dirLocation)
    if self.server == null then return []
    if dirLocation isa list then dirLocation = dirLocation[0] + "/" + dirLocation[1]
    file = self.server.host_computer.File(dirLocation)
    if file == null or not file.is_folder then return []
    ret = []
    for child in file.get_files
        ret.push(child)
    end for
    return ret
end function

GameServer.Server.listDirsIn = function(dirLocation)
    if self.server == null then return []
    if dirLocation isa list then dirLocation = dirLocation[0] + "/" + dirLocation[1]
    file = self.server.host_computer.File(dirLocation)
    if file == null or not file.is_folder then return []
    ret = []
    for child in file.get_folders
        ret.push(child)
    end for
    return ret
end function

GameServer.Server.mkFilename = function(dirname, basename)
    if dirname isa string then return [dirname, basename]
    if dirname.len != 2 then exit("mkFilename: Invalid API usage")
    nextDir = dirname[0] + "/" + dirname[1]
    return [nextDir, basename]
end function

GameServer.Server.getOrMkFile = function(filename)
    if not filename isa list or filename.len != 2 then exit("getOrMkFile: Invalid API usage")
    if self.server == null then return null
    self.server.host_computer.touch(filename[0], filename[1])
    return self.server.host_computer.File(filename[0] + "/" + filename[1])
end function

GameServer.Server.getExistingFile = function(filename)
    if not filename isa list or filename.len != 2 then exit("getExistingFile: Invalid API usage")
    if self.server == null then return null
    return self.server.host_computer.File(filename[0] + "/" + filename[1])
end function

GameServer.Server.mkNewFile = function(filename)
    if not filename isa list or filename.len != 2 then exit("mkNewFile: Invalid API usage")
    if self.server == null then return null
    file = self.server.host_computer.File(filename[0] + "/" + filename[1])
    if file != null then return null
    self.server.host_computer.touch(filename[0], filename[1])
    return self.server.host_computer.File(filename[0] + "/" + filename[1])
end function

GameServer.Server.mkDir = function(dirLocation)
    if dirLocation isa list then dirLocation = dirLocation[0] + "/" + dirLocation[1]
    pos = dirLocation.lastIndexOf("/")
    self.server.host_computer.create_folder(dirLocation[:pos], dirLocation[pos+1:])
    file = self.server.host_computer.File(dirLocation)
    if file == null or not file.is_folder then return null
    return file
end function

GameServer.Server.rmFile = function(filename)
    if not filename isa list or filename.len != 2 then exit("rmFile: Invalid API usage")
    if self.server == null then return null
    file = self.server.host_computer.File(filename[0] + "/" + filename[1])
    if file != null then return file.delete
    return self.server.host_computer.File(filename[0] + "/" + filename[1]) == null
end function

GameServer.Server.rmTree = function(baseDir)
    if baseDir isa list then baseDir = baseDir[0] + "/" + baseDir[1]
    if baseDir isa string then baseDir = self.server.host_computer.File(baseDir)
    visited = {}
    remaining = [baseDir]
    while remaining.len > 0
        parent = remaining.pop()
        if parent != null then
            subfolders = parent.get_folders
            for child in parent.get_files
                child.delete
            end for
            if subfolders.len > 0 and not visited.hasIndex(parent.path) then
                // Need to remove the child folders before this can be removed.
                remaining.push(parent)
                remaining = remaining + subfolders
            else
                // Try to delete.  May not work, but we won't revisit this parent.
                parent.delete
            end if
            visited[parent.path] = true
        end if
    end while
end function

// ====================================================================

// ChatRoom A room where players can chat.
//    Creation returns either a string (meaning error) or an object.
GameServer.ChatRoom = {}
GameServer.ChatRoom.mk = function(server, roomDir, playerName, force)
    if IsInvalidName(playerName) then return null
    userFile = server.mkFilename(roomDir, playerName)
    if not force then
        file = server.getExistingFile(userFile)
        if file != null then return null
    end if
    res = server.post(userFile, "Joins")
    if res != null then
        print("Error joining chatroom: " + res)
        return null
    end if

    ret = new GameServer.ChatRoom
    ret.playerName = playerName
    ret.server = server
    ret.roomDir = roomDir
    ret.userFile = userFile
    ret.knownPlayers = {}
    ret.first = true
    return ret
end function

// ChatRoom.Disconnect Disconnect from the room.
GameServer.ChatRoom.Disconnect = function()
    if self.server == null then return "not connected"
    self.server.closePost(self.userFile)
    self.server = null
end function

// ChatRoom.ListPlayers Get the list of other player names in the room.
GameServer.ChatRoom.ListPlayers = function()
    if self.server == null then return null
    ret = []
    for item in self.server.listIn(self.roomDir)
        if item.name != self.playerName then ret.push(item.name)
    end for
    return ret
end function

// ChatRoom.GetPlayerText Get the player's text comments since the last request.
//
// Returns a list of [datetime, playername, text]
GameServer.ChatRoom.GetPlayerText = function(name)
    if self.server == null then return null
    ret = []
    for item in self.server.pull(self.server.mkFilename(self.roomDir, name))
        ret.push([item[1], item[2]])
    end for
    return ret
end function

// ChatRoom.Post Post a message as the player to the server lobby.
GameServer.ChatRoom.Post = function(message)
    if self.server == null then return "Not connected"
    return self.server.post(self.userFile, message)
end function

// ChatRoom.PullMessages Get the latest unread messages.
//
// Returns a list of each message, where each item in the list is [date, user, message, dateEpoch]
GameServer.ChatRoom.PullMessages = function()
    if self.server == null then return []
    ret = []
    now = current_date
    nowEpoch = dateEpoch(now)
    lastPlayers = self.knownPlayers
    self.knownPlayers = {}
    for item in self.server.listIn(self.roomDir)
        if item.name != self.playerName and item.name[0] != "." then
            self.knownPlayers[item.name] = true
            if lastPlayers.hasIndex(item.name) then
                lastPlayers.remove(item.name)
            else if not self.first then
                ret.push([now, item.name, item.name + " entered the room.", nowEpoch])
            end if
            location = self.server.mkFilename(self.roomDir, item.name)
            for msg in self.server.pull(location)
                if msg[2].len > 0 then
                    ret.push([msg[1], item.name, msg[2], dateEpoch(msg[1])])
                end if
            end for
        end if
    end for
    for name in lastPlayers.indexes
        ret.push([now, name, name + " left the room.", nowEpoch])
    end for
    self.first = false
    // sort by date (index [3] in each item).
    QuickSort(ret, @String3AscOrder)
    return ret
end function

// ====================================================================

// Lobby The game lobby.  Allows for chats and game matching.
GameServer.Lobby = {}
GameServer.Lobby.mk = function(server, playerName, force)
    if IsInvalidName(playerName) then return null
    ret = new GameServer.Lobby
    ret.playerName = playerName
    ret.server = server
    ret.lobbyDir = server.serverRootDir + "/Lobby"
    // KnownGames map of game name -> GameInfo
    ret.KnownGames = {}
    ret.pendingGameState = {}  // map of game name / instance name -> state
    ret.chatRoom = GameServer.ChatRoom.mk(server, ret.lobbyDir, playerName, force)
    if ret.chatRoom == null then return null
    return ret
end function

// Lobby.Disconnect Disconnect from the lobby.
GameServer.Lobby.Disconnect = function()
    if self.server == null then return "not connected"
    if self.chatRoom != null then self.chatRoom.Disconnect
    self.chatRoom = null
    self.server = null
    self.KnownGames = {}
end function

// Lobby.GetMembers Get the members in the lobby.
GameServer.Lobby.GetMembers = function()
    if self.chatRoom == null then return []
    return self.chatRoom.ListPlayers()
end function

// Lobby.PullMessages Pull messages from players and pending game state changes.
GameServer.Lobby.PullMessages = function()
    if self.server == null or self.chatRoom == null then return []
    ret = []
    now = current_date
    epoch = dateEpoch(now)

    // Pending game state changes.
    prevGameState = self.pendingGameState
    self.pendingGameState = {}
    for gameName in self.server.KnownGames.indexes
        game = self.server.KnownGames[gameName]
        game.FetchPendingGames
        for pendingName in game.PendingGames.indexes
            gpn = "/" + gameName + "/" + pendingName
            pending = game.PendingGames[pendingName]
            status = pending.Status
            self.pendingGameState[gpn] = status
            if prevGameState.hasIndex(gpn) then
                if prevGameState[gpn] != status then
                    ret.push([now, gpn, "/emote " + status, epoch])
                end if
                prevGameState.remove(gpn)
            else
                ret.push([now, gpn, "/emote (new) " + status, epoch])
            end if
        end for
    end for
    for name in prevGameState.indexes
        ret.push([now, name, "/emote (closed)", epoch])
    end for
// Chat messages.
    ret = ret + self.chatRoom.PullMessages

    // sort by date (index [3] in each item).
    QuickSort(ret, @String3AscOrder)
    return ret
end function

// Lobby.PostMessage Post a message to the server.
GameServer.Lobby.PostMessage = function(msg)
    if self.chatRoom != null then self.chatRoom.Post(msg)
end function

// ====================================================================
// One Game information

GameServer.GameInfo = {}
GameServer.GameInfo.mk = function(server, aboutFile, infoFile)
    // aboutFile - the File object for the `about.txt` file.
    // infoFile - the File object for the `game.inf` file.
    ret = new GameServer.GameInfo
    ret.About = aboutFile.get_content
    ret.server = server
    aboutPath = aboutFile.path
    pos = aboutPath.lastIndexOf("/")
    if pos == null then return null
    ret.gameDir = aboutPath[:pos]
    pos = ret.gameDir.lastIndexOf("/")
    if pos == null then return null
    ret.SimpleName = ret.gameDir[pos + 1:]
    ret.pendingGameDir = server.serverRootDir + "/Pending/" + ret.SimpleName
    ret.activeGameDir = server.serverRootDir + "/Active/" + ret.SimpleName
    ret.knownPendingGames = {}
    ret.details = ParsePropertyFile(infoFile.get_content)
    ret.Name = null
    ret.Description = null
    ret.MinPlayers = 0
    ret.MaxPlayers = 0
    ret.Client = null
    ret.Host = null
    ret.ClientBin = null
    ret.HostBin = null
    if ret.details.hasIndex("name") then ret.Name = ret.details.name
    if ret.details.hasIndex("desc") then ret.Description = ret.details.desc
    if ret.details.hasIndex("min-players") then ret.MinPlayers = ret.details["min-players"].to_int
    if ret.details.hasIndex("max-players") then ret.MaxPlayers = ret.details["max-players"].to_int
    if ret.details.hasIndex("client") then ret.Client = ret.details.client
    if ret.details.hasIndex("client-bin") then ret.ClientBin = ret.details["client-bin"]
    if ret.details.hasIndex("host") then ret.Host = ret.details.host
    if ret.details.hasIndex("host-bin") then ret.HostBin = ret.details["host-bin"]
    if ret.Name == null or ret.MinPlayers <= 0 or ret.Client == null then return null
    if ret.Host != null and ret.Host.indexOf("/") != null then return null
    if ret.Client.indexOf("/") != null then return null
    return ret
end function

// GameInfo.PendingGames Get the pending games list or, if not fetched yet, will fetch it.
GameServer.GameInfo.PendingGames = function()
    if self.knownPendingGames.len > 0 then return self.knownPendingGames
    return self.FetchPendingGames
end function

// GameInfo.FetchPendingGames Refresh the map of names to pending games for the game.
GameServer.GameInfo.FetchPendingGames = function()
    if self.server == null then return {}
    self.knownPendingGames = {}
    for pendingDir in self.server.listDirsIn(self.pendingGameDir)
        pending = GameServer.PendingGame.mk(self, pendingDir, self.server.mkFilename(self.activeGameDir, pendingDir.name))
        if pending != null then
            self.knownPendingGames[pending.InstanceName] = pending
        end if
    end for
    return self.knownPendingGames
end function

// GameInfo.JoinGame Join a pending game.
GameServer.GameInfo.JoinGame = function(instanceName, playerName)
    if self.server == null or self.server.server == null then return null
    if IsInvalidName(playerName) then return null
    if self.knownPendingGames.len <= 0 then self.FetchPendingGames
    self.buildClientBin()
    if self.ClientBin == null then
        print("Error: could not create the client binary file.  Aborting.")
        return null
    end if
    if not self.knownPendingGames.hasIndex(instanceName) then
        print("Error: could not find instance '" + instanceName + "'")
        return null
    end if
    pendingGame = self.knownPendingGames[instanceName]
    pendingGame.Fetch
    if pendingGame.Players.len > self.MaxPlayers then
        print("Error: instance '" + instanceName + "' at player limit")
        return null
    end if
    file = self.server.getOrMkFile(self.server.mkFilename(pendingGame.pendingDir, playerName))
    if file == null then return null
    file.set_content("joined")
    return GameServer.JoinedInstance.mk(self.server, playerName, pendingGame, false)
end function

// GameInfo.HostGame Start a new instance of a game.  Creates the pending lobby.
GameServer.GameInfo.HostGame = function(instanceName, playerName)
    if self.server == null or self.server.server == null then return null
    self.buildHostBin()
    if self.HostBin == null then
        print("Error: could not create the host binary file.  Aborting.")
        return null
    end if
    // TODO check if the instance name already exists in either Pending or Active.
    server = self.server
    gameDir = server.mkFilename(self.pendingGameDir, instanceName)
    cleanUp = function()
        server.rmTree(gameDir)
        return null
    end function
    hostDir = server.mkDir(gameDir)
    if hostDir == null then return cleanUp()
    chatDir = server.mkDir(server.mkFilename(gameDir, ".chat.d"))
    if chatDir == null then return cleanUp()
    hostFile = server.mkNewFile(server.mkFilename(gameDir, ".host.txt"))
    if hostFile == null then return cleanUp()
    hostFile.set_content(playerName)
    pendingGame = GameServer.PendingGame.mk(self, hostDir, server.mkFilename(self.activeGameDir, instanceName))
    if pendingGame == null then return null
    return GameServer.JoinedInstance.mk(self.server, playerName, pendingGame, true)
end function

GameServer.GameInfo.buildClientBin = function()
    binPath = self.ClientBin
    self.ClientBin = null
    res = self.buildBin(self.Client, binPath)
    if res != null then self.ClientBin = res.path
end function

GameServer.GameInfo.buildHostBin = function()
    if self.Host == null then
        self.buildClientBin()
        self.HostBin = self.ClientBin
    else
        binPath = self.HostBin
        self.HostBin = null
        res = self.buildBin(self.Host, binPath)
        if res != null then self.HostBin = res.path
    end if
end function

GameServer.GameInfo.buildBin = function(sourceFile, sourceBin = null)
    // This is ... special.  Due to the game file information properties.
    // source file is the name of the file, which must be in the gameDir directory.
    srvFile = self.server.getExistingFile(self.server.mkFilename(self.gameDir, sourceFile))
    if srvFile == null or srvFile.is_binary then return null
    // Local computer file, not server file.
    get_shell.host_computer.touch(DOWNLOAD_DIR, srvFile.name)
    file = get_shell.host_computer.File(DOWNLOAD_DIR + "/" + srvFile.name)
    if file == null then return null
    file.set_content(srvFile.get_content)
    if sourceFile[-4:] == ".src" then
        if sourceBin == null then sourceBin = file.path[:-4]
        parent = sourceBin[:sourceBin.lastIndexOf("/")]
        res = get_shell.build(file.path, parent)
        if res != "" then
            print("Error: failed to build " + sourceFile + ": " + res)
            return null
        end if
        name = file.path[file.path.lastIndexOf("/") + 1:]
        // Ignore the sourceBin real name.  Just use whatever it compiles to.
        compiledName = parent + "/" + name[:-4]
        file = get_shell.host_computer.File(compiledName)
        if file == null then
            print("Error: compiled " + sourceFile + ", but couldn't find the compiled file")
        end if
        return file
    else if sourceFile[-7:] == ".bundle" then
        if sourceBin == null then return null
        if sourceBin[:2] == "~/" or sourceBin[:2] == "-/" then
            sourceBin = home_dir + sourceBin[1:]
        end if
        get_shell.launch(IMPORT_BIN, file.path)
        return get_shell.host_computer.File(sourceBin)
    else
        print("Error: Don't know how to build source file " + sourceFile)
        return null
    end if
end function

// ====================================================================
// Pending Game information

GameServer.PendingGame = {}
GameServer.PendingGame.mk = function(gameInfo, pendingDir, activeDirPath)
    ret = new GameServer.PendingGame
    ret.server = gameInfo.server
    ret.gameInfo = gameInfo
    ret.InstanceName = pendingDir.name
    ret.HostPlayer = null
    ret.Players = {}  // Includes the host player.
    ret.pendingDir = pendingDir.path
    ret.activeDir = activeDirPath
    ret.chatDir = gameInfo.server.mkFilename(pendingDir.path, ".chat.d")
    ret.Fetch()
    return ret
end function

// State Check if the game has started; returns "pending", "full", "needs-more-players", "starting", "active", or "abandoned"
GameServer.PendingGame.Status = function()
    // This is done by checking that first the game directory exists and that this one doesn't.
    self.Fetch
    activeFiles = self.server.listIn(self.activeDir)
    if activeFiles.len <= 0 then
        if self.HostPlayer == null then return "abandoned"
        if self.Players.len >= self.gameInfo.MaxPlayers then return "full"
        if self.Players.len < self.gameInfo.MinPlayers then return "needs-more-players"
        return "pending"
    end if
    if self.HostPlayer == null then return "active"
    return "starting"
end function

// PendingGame.Fetch Fetch the list of players for the game.  Refreshes from the server.
GameServer.PendingGame.Fetch = function()
    self.HostPlayer = null
    self.Players = {}
    for file in self.server.listIn(self.pendingDir)
        if file.name == ".host.txt" then
            self.HostPlayer = file.get_content
        else if file.name[0] != "." then
            self.Players[file.name] = file.get_content
        end if
    end for
    return self.Players
end function

GameServer.PendingGame.JoinChat = function(playerName, force)
    return GameServer.ChatRoom.mk(self.server, self.chatDir, playerName, force)
end function

GameServer.PendingGame.close = function()
    self.server = null
end function

// ====================================================================
// Joined Game Instance information

GameServer.JoinedInstance = {}
GameServer.JoinedInstance.mk = function(server, playerName, pendingGame, hosting)
    if IsInvalidName(playerName) then return null
    ret = new GameServer.JoinedInstance
    ret.server = server
    ret.pendingGame = pendingGame // PendingGame instance
    ret.playerName = playerName
    ret.playerFile = server.mkFilename(pendingGame.pendingDir, playerName)
    pfile = server.getOrMkFile(ret.playerFile)
    if pfile == null then return null
    if hosting then
        pfile.set_content("hosting")
    else
        pfile.set_content("joined")
    end if
    ret.hosting = hosting
    ret.lastKnownState = null
    ret.knownPlayerState = {}
    ret.chatRoom = pendingGame.JoinChat(playerName, true)
    if ret.chatRoom == null then return null
    if hosting then ret.SetStatus("instance host")
    return ret
end function

// JoinedInstance.InstanceStatus Instance status.
GameServer.JoinedInstance.InstanceStatus = function()
    if self.pendingGame == null then return "left"
    return self.pendingGame.Status
end function

//JoinedInstance.InstanceName Instance name
GameServer.JoinedInstance.InstanceName = function()
    if self.pendingGame == null then return "N/A"
    return self.pendingGame.InstanceName
end function

// JoinedInstance.Disconnect Leave this game instance.
GameServer.JoinedInstance.Disconnect = function()
    if self.server == null or self.pendingGame == null then return
    if self.chatRoom != null then self.chatRoom.Disconnect()
    self.chatRoom = null
    if self.hosting then
        // First, remove the _host.txt file.  That's the primary signal that the instance is gone.
        // Note that for starting a game, removing this file is the last action to indicate the game is active.
        self.server.rmFile(self.server.mkFilename(self.pendingGame.pendingDir, ".host.txt"))
        self.server.rmTree(self.pendingGame.pendingDir)
        self.pendingGame.close()
    else
        if self.server != null then self.server.rmFile(self.playerFile)
    end if
    self.server = null
    self.pendingGame = null
end function

// JoinedInstance.IsHosting Is this instance hosted by the current player?
GameServer.JoinedInstance.IsHosting = function()
    return self.hosting
end function

// JoinedInstance.SetStatus Set this player's status.
GameServer.JoinedInstance.SetStatus = function(status)
    if self.server == null then return
    file = self.server.getExistingFile(self.playerFile)
    if file != null then file.set_content(status)
end function

// JoinedInstance.FetchPlayerStatus Get the other players' status.
GameServer.JoinedInstance.FetchPlayerStatus = function()
    if self.server == null or self.pendingGame == null then return {}
    players = self.pendingGame.Fetch
    if players.hasIndex(self.playerName) then players.remove(self.playerName)
    self.knownPlayerState = players
    return players
end function

// JoinedInstance.Game Get the game information
GameServer.JoinedInstance.Game = function()
    if self.pendingGame == null then return null
    return self.pendingGame.gameInfo
end function

// JoinedInstance.PullMessages Fetch messages for display.
GameServer.JoinedInstance.PullMessages = function()
    if self.server == null or self.chatRoom == null then return []
    ret = []
    now = current_date
    epoch = dateEpoch(now)

    // Server state change
    prevState = self.lastKnownState
    newState = self.InstanceStatus
    if newState != prevState then
        ret.push([now, "/state/", "Game state now " + newState, epoch])
    end if
    self.lastKnownState = newState

    // Player state changes.
    prevPlayerState = self.knownPlayerState
    players = self.FetchPlayerStatus
    for playerName in players.indexes
        pstate = players[playerName]
        if prevPlayerState.hasIndex(playerName) then
            if prevPlayerState[playerName] != pstate then
                ret.push([now, playerName, "/empte changed state to " + pstate, epoch])
            end if
            prevPlayerState.remove(playerName)
        else
            ret.push([now, playerName, "/emote joined the instance.", epoch])
        end if
    end for
    for name in prevPlayerState.indexes
        ret.push([now, name, "/emote left the instance.", epoch])
    end for
    // Chat messages.
    ret = ret + self.chatRoom.PullMessages

    // sort by date (index [3] in each item).
    QuickSort(ret, @String3AscOrder)
    return ret
end function

GameServer.JoinedInstance.PostMessage = function(msg)
    if self.chatRoom != null then self.chatRoom.Post(msg)
end function

// JoinedInstance.Launch Join the game, either by hosting it or joining it.
GameServer.JoinedInstance.Launch = function()
    if self.hosting then
        return self.hostServer()
    else
        return self.joinServer()
    end if
end function

// JoinedInstance.CanStart Can this instance be started?
GameServer.JoinedInstance.CanStart = function()
    if self.server == null or not self.hosting then return "not hosting"
    self.pendingGame.Fetch()
    count = self.pendingGame.Players.len
    if count > self.pendingGame.gameInfo.MaxPlayers then
        return "Too many players pending (" + count + ").  Someone needs to drop first."
    end if
    if count < self.pendingGame.gameInfo.MinPlayers then
        return "Too few players pending (" + count + ").  Someone needs to join."
    end if
    return null
end function

GameServer.JoinedInstance.joinServer = function()
    if self.server == null or self.pendingGame == null then return
    if self.pendingGame.gameInfo.ClientBin == null then
        print("Error: you must prepare the game before starting it.")
        return
    end if
    hostFile = get_shell.host_computer.File(self.pendingGame.gameInfo.ClientBin)
    if hostFile == null or not hostFile.is_binary then
        print("Error: could not find the host game program.  Did it fail to build?")
        return
    end if

    if self.InstanceStatus != "active" then
        print("Error: instance is no longer active, but '" + self.InstanceStatus + "'")
        return
    end if

    file = self.server.getOrMkFile(self.server.mkFilename(self.pendingGame.activeDir, self.playerName))
    if file == null then
        self.server.rmTree(self.pendingGame.activeDir)
        print("Error: failed to join the active game")
        return
    end if
    file.set_content("player")

    if self.chatRoom != null then self.chatRoom.Disconnect()
    self.chatRoom = null

    // Set up the shared object.
    //   This breaks all kinds of OO rules.
    obj = get_custom_object
    obj.gameDir = self.pendingGame.activeDir[0] + "/" + self.pendingGame.activeDir[1]
    obj.server = self.server.server.host_computer
    obj.controller = globals.CONTROLLER_FILE
    obj.playerName = self.playerName

    // Launch the game.
    if get_shell.launch(hostFile.path) != true then
        print("Failed to launch the client program " + hostFile.path)
    end if

    // The game execution completed.  Now clean up after ourself.
    self.server.rmFile(self.server.mkFilename(self.pendingGame.activeDir, self.playerName))

    // Then close this object off.  It can't be used again.
    self.pendingGame.close()
    self.server = null
    self.pendingGame = null
end function

GameServer.JoinedInstance.hostServer = function()
    if self.server == null or self.pendingGame == null then return
    if self.pendingGame.gameInfo.HostBin == null then
        print("Error: you must prepare the game before starting it.")
        return
    end if
    hostFile = get_shell.host_computer.File(self.pendingGame.gameInfo.HostBin)
    if hostFile == null or not hostFile.is_binary then
        print("Error: could not find the host game program (" + self.pendingGame.gameInfo.HostBin + ").  Did it fail to build?")
        return
    end if

    // Final refresh and state check.
    self.pendingGame.Fetch()
    if self.pendingGame.Players.len > self.pendingGame.gameInfo.MaxPlayers then
        print("Error: too many players pending.  Someone needs to drop first.")
        return
    end if
    if self.pendingGame.Players.len < self.pendingGame.gameInfo.MinPlayers then
        print("Error: too few players pending.  Someone needs to join.")
        return
    end if
    // TODO ensure all the players have a "ready" state.

    if self.chatRoom != null then self.chatRoom.Post("Host has started the game.")

    // Start up the active game.
    players = []
    for name in self.pendingGame.Players.indexes
        if name != self.playerName then players.push(name)
    end for
    QuickSort(players, @BasicAscOrder)
    content = self.playerName
    for name in players
        content = content + char(10) + name
    end for
    res = self.server.mkDir(self.pendingGame.activeDir)
    if res == null then
        print("Error: Failed to create the active game directory")
        return
    end if
    file = self.server.getOrMkFile(self.server.mkFilename(self.pendingGame.activeDir, ".host.txt"))
    if file == null then
        self.server.rmTree(self.pendingGame.activeDir)
        print("Error: failed to construct the active game directory correctly")
        return
    end if
    file.set_content(content)
    file = self.server.getOrMkFile(self.server.mkFilename(self.pendingGame.activeDir, self.playerName))
    if file == null then
        self.server.rmTree(self.pendingGame.activeDir)
        print("Error: failed to construct the active game directory accurately")
        return
    end if
    file.set_content("host")

    if self.chatRoom != null then self.chatRoom.Disconnect()
    self.chatRoom = null

    // At the very end of instance launching, the _host.txt file is removed then the pending directory.
    self.server.rmFile(self.server.mkFilename(self.pendingGame.pendingDir, ".host.txt"))
    self.server.rmTree(self.pendingGame.pendingDir)

    // Set up the shared object.
    //   This breaks all kinds of OO rules.
    obj = get_custom_object
    obj.gameDir = self.pendingGame.activeDir[0] + "/" + self.pendingGame.activeDir[1]
    obj.server = self.server.server.host_computer
    obj.controller = globals.CONTROLLER_FILE
    obj.playerName = self.playerName

    // Launch the game.
    if get_shell.launch(hostFile.path) != true then
        print("Failed to launch the host program " + hostFile.path)
    end if

    // The game execution completed.  Now clean up the active game directory.
    self.server.rmTree(self.pendingGame.activeDir)

    // Then close this object off.  It can't be used again.
    self.pendingGame.close()
    self.server = null
    self.pendingGame = null
end function

// ====================================================================
// Utility Stuff

// dateEpoch Static function that turns the current_date string into a sortable value.
dateEpoch = function(dateStr)
    // Keeps everything as-is except the month (which is turned into a 2 digit number) and the order.
    dateSegments = dateStr.split(" - ")
    date = dateSegments[0].split("/")
    day = date[0]
    month = date[1]
    if dateEpochMonths.hasIndex(month) then month = dateEpochMonths[month]
    year = date[2]
    return year + month + day + dateSegments[1]
end function

dateEpochMonths = {
    "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04", "May": "05", "Jun": "06",
    "Jul": "07", "Aug": "08", "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12",
}

// QuickSort Sort the list (internally) using the comparison function.
QuickSort = function(list, comparison)
    return QuickSort__entry(list, @comparison, 0, list.len - 1)
end function

QuickSort__entry = function(list, comparison, lo, hi)
    if lo >= 0 and hi >= 0 and lo < hi then
        p = QuickSort__partition(list, @comparison, lo, hi)
        QuickSort__entry(list, @comparison, lo, p)
        QuickSort__entry(list, @comparison, p + 1, hi)
    end if
end function

QuickSort__partition = function(list, comparison, lo, hi)
    pivot = list[floor((hi - lo) / 2) + lo]
    i = lo - 1
    j = hi + 1
    while true
        i = i + 1
        while comparison(list[i], pivot) < 0
            i = i + 1
        end while
        j = j - 1
        while comparison(list[j], pivot) > 0
            j = j - 1
        end while
        if i >= j then return j
        tmp = list[i]
        list[i] = list[j]
        list[j] = tmp
    end while
end function

// String3AscOrder Sort by the third index of the two arrays.
String3AscOrder = function(a, b)
    if a[3] == b[3] then return 0
    if a[3] < b[3] then return -1
    return 1
end function

// BasicAscOrder Sort ascending
BasicAscOrder = function(a, b)
    if a == b then return 0
    if a < b then return -1
    return 1
end function

// ParsePropertyFile Parse the property file formatted contents.
ParsePropertyFile = function(contents)
    if contents == null then return {}
    ret = {}
    for line in contents.split(char(10))
        // Remove leading whitespace
        while line.len > 0 and line[0] == " "
            line = line[1:]
        end while
        if line.len <= 0 then continue
        if line[0] == "#" then continue
        pos = line.indexOf("=")
        if pos > 0 then
            ret[line[:pos]] = line[pos+1:]
        end if
    end for
    return ret
end function

// IsInvalidName Is the name invalid?
IsInvalidName = function(name)
    for ch in name.values
        cd = ch.code
        if (cd < IsInvalidName__R1L and cd > IsInvalidName__R1H) and (cd < IsInvalidName__R2L and cd > IsInvalidName__R2H) and (cd < IsInvalidName__R3L and cd > IsInvalidName__R3H) then return true
    end for
    return false
end function
IsInvalidName__R1L = "a".code
IsInvalidName__R1H = "z".code
IsInvalidName__R2L = "A".code
IsInvalidName__R2H = "Z".code
IsInvalidName__R3L = "0".code
IsInvalidName__R3H = "9".code

// Words Split the text into distinct words, stripped of surrounding spaces.
Words = function(text)
    parts = text.split(" ")
    ret = []
    for part in parts
        if part.len > 0 then ret.push(part)
    end for
    return ret
end function

if locals == globals then main()
